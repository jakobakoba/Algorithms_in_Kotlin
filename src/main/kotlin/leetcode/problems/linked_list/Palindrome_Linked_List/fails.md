
### для неоптимального:

wrong answer for [1,2]

- Смотри вниз на 1,0,0. То, что тут написано неактуально: 
оказалось изначальные стартовые позиции для left and right 
не обрабатываются, то есть у меня return false есть только 
внутри while цикла, while list[left] == list[right] не работает
и поэтому в цикл даже не входит, идет мимо цикла и возвращает 
return true. Сделал такой случай что после установления начальных 
позиций для left and right сразу проверяю равны они или нет.

wrong answer for [1,0,0]

- Я записал условие list[left] == list[right] в while цикл и 
из-за этого все пошло наперекосяк. Не надо записывать такое условие
в цикл. В цикле должно быть только условие для pointers
left >= 0 and right < n. Все и точка. Верхнее для [1,2] тоже 
относится к этому.


### Для оптимального
Line 26: Char 22: error: only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type ListNode?
if (dummy.`val` != prev.`val`){
- если ListNode? то обязательно внутри цикла надо уточнить "!!" 
либо "?". Но можно в цикле написать условие while(dummy != null)
тогда уже не надо уточнять внутри цикла !! или ? так как 
если будет null то программа просто выйдет из цикла. 
